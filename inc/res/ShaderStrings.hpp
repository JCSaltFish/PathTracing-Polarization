/**
 * @file ShaderStrings.hpp
 * @brief Auto-generated shader strings - DO NOT EDIT.
 */

#pragma once

#include <string>
#include <unordered_map>

namespace ShaderStrings
{

// Source: pathTracer.comp
inline constexpr const char* PATHTRACER_COMP =
    "/**\n"
    " * @file pathTracer.comp\n"
    " * @brief Compute shader for path tracing rendering.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "#ifndef VULKAN\n"
    "#extension GL_ARB_bindless_texture : require\n"
    "#else\n"
    "#extension GL_EXT_nonuniform_qualifier : require\n"
    "#endif\n"
    "\n"
    "layout(local_size_x = 32, local_size_y = 32) in;\n"
    "\n"
    "layout(binding = 0, rgba32f) uniform image2D u_outImg; // Output image\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct representing the scene parameters.\n"
    " */\n"
    "layout(binding = 1) uniform Scene {\n"
    "    int resX; // Resolution in X\n"
    "    int resY; // Resolution in Y\n"
    "    int traceDepth; // Trace depth\n"
    "    int currentSample; // Current sample count\n"
    "} u_scene; // Scene parameters\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct representing the camera parameters.\n"
    " */\n"
    "layout(binding = 2) uniform Camera {\n"
    "    vec4 pos; // Camera position\n"
    "    vec4 dir; // Camera direction\n"
    "    vec4 up; // Camera up vector\n"
    "\n"
    "    float focal; // Focal length\n"
    "    float fov; // Field of view\n"
    "    float focusDist; // Focus distance\n"
    "    float fStop; // F-stop value\n"
    "} u_camera; // Camera parameters\n"
    "\n"
    "#ifdef VULKAN\n"
    "layout(binding = 3) uniform sampler2D u_textures[]; // Array of textures\n"
    "#else\n"
    "layout(binding = 3) buffer Textures {\n"
    "    sampler2D u_textures[]; // Array of textures\n"
    "};\n"
    "#endif\n"
    "\n"
    "/**\n"
    " * @brief Sample a texture at given UV coordinates.\n"
    " * @param index The index of the texture.\n"
    " * @param uv The UV coordinates.\n"
    " * @return The sampled color.\n"
    " */\n"
    "vec4 sampleTexture(uint index, vec2 uv) {\n"
    "#ifdef VULKAN\n"
    "    return texture(u_textures[nonuniformEXT(index)], uv);\n"
    "#else\n"
    "    return texture(sampler2D(u_textures[index]), uv);\n"
    "#endif\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a vertex in the mesh.\n"
    " */\n"
    "struct Vertex {\n"
    "    vec4 pos; // Position\n"
    "    vec4 normal; // Normal\n"
    "    vec4 tangent; // Tangent\n"
    "    vec2 texCoord; // Texture Coordinate\n"
    "    vec2 padding; // Padding for alignment\n"
    "};\n"
    "/**\n"
    " * @brief Storage buffer containing the vertices of the mesh.\n"
    " */\n"
    "layout(binding = 4) readonly buffer Vertices {\n"
    "    Vertex vertices[]; // Array of vertices\n"
    "} b_vertices; // Vertex buffer\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a triangle in the mesh.\n"
    " */\n"
    "struct Triangle {\n"
    "    uint v0; // Index of vertex 0\n"
    "    uint v1; // Index of vertex 1\n"
    "    uint v2; // Index of vertex 2\n"
    "    uint idxMaterial; // Index of the material\n"
    "};\n"
    "/**\n"
    " * @brief Storage buffer containing the triangles of the mesh.\n"
    " */\n"
    "layout(binding = 5) readonly buffer Triangles {\n"
    "    Triangle triangles[]; // Array of triangles\n"
    "} b_triangles; // Triangle buffer\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a material for a mesh.\n"
    " */\n"
    "struct Material {\n"
    "    int type; // Material type\n"
    "    float roughness; // Roughness\n"
    "    float intensity; // Intensity\n"
    "    float ior; // Index of Refraction\n"
    "\n"
    "    uint flags; // Material flags\n"
    "    uint idxNormalTex; // Index of normal texture\n"
    "    uint idxRoughnessTex; // Index of roughness texture\n"
    "    uint idxIntensityTex; // Index of intensity texture\n"
    "};\n"
    "\n"
    "const int MATERIAL_TYPE_DIFFUSE = 0; // Diffuse material\n"
    "const int MATERIAL_TYPE_SPECULAR = 1; // Specular material\n"
    "const int MATERIAL_TYPE_GLOSSY = 2; // Glossy material\n"
    "const int MATERIAL_TYPE_TRANSLUCENT = 3; // Translucent material\n"
    "\n"
    "const uint MATERIAL_NORMAL_MAP = 1 << 0; // Has normal texture\n"
    "const uint MATERIAL_ROUGHNESS_MAP = 1 << 1; // Has roughness texture\n"
    "const uint MATERIAL_INTENSITY_MAP = 1 << 2; // Has intensity texture\n"
    "\n"
    "/**\n"
    " * @brief Storage buffer containing the materials of the mesh.\n"
    " */\n"
    "layout(binding = 6) readonly buffer Materials {\n"
    "    Material materials[]; // Array of materials\n"
    "} b_materials; // Material buffer\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a BVH node.\n"
    " */\n"
    "struct BvhNode {\n"
    "    uint idx; // Index of this node\n"
    "    uint rChildOffset; // Offset to the right child node\n"
    "    uint idxTriangle; // Index of the triangle (if leaf node)\n"
    "    uint leafFlag; // Flag indicating if this is a leaf node\n"
    "\n"
    "    vec4 aabbMin; // Minimum AABB coordinates\n"
    "    vec4 aabbMax; // Maximum AABB coordinates\n"
    "};\n"
    "/**\n"
    " * @brief Storage buffer containing the BVH nodes.\n"
    " */\n"
    "layout(binding = 7) readonly buffer BVH {\n"
    "    BvhNode bvhNodes[]; // Array of BVH nodes\n"
    "} b_BVH; // BVH buffer\n"
    "\n"
    "const float EPS = 0.00001; // Small epsilon value\n"
    "const float INFINITY = 1e20; // Large value representing infinity\n"
    "const float PI = 3.14159265359; // Value of pi\n"
    "\n"
    "uint g_rngState = 0; // Global RNG state\n"
    "/**\n"
    " * @brief Initialize the RNG state based on pixel coordinates and current sample.\n"
    " * @param pixel The pixel coordinates.\n"
    " * @param currentSample The current sample index.\n"
    " */\n"
    "void initRngState(ivec2 pixel, int currentSample) {\n"
    "    g_rngState = uint(pixel.x * 1973u + pixel.y * 9277u + currentSample * 26699u) | 1u;\n"
    "}\n"
    "/**\n"
    " * @brief Generate a random float in the range [0, 1).\n"
    " * @return A random float.\n"
    " */\n"
    "float rand() {\n"
    "    g_rngState ^= g_rngState << 13;\n"
    "    g_rngState ^= g_rngState >> 17;\n"
    "    g_rngState ^= g_rngState << 5;\n"
    "    return float(g_rngState) * (1.0 / 4294967296.0);\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Build an orthonormal basis (u, v) given a normal vector (axis).\n"
    " * @param axis The normal vector.\n"
    " * @param[out] u Output vector for the first tangent.\n"
    " * @param[out] v Output vector for the second tangent.\n"
    " */\n"
    "void buildOrthonormalBasis(vec3 axis, out vec3 u, out vec3 v) {\n"
    "    vec3 tmp = abs(axis.x) < 1.0 - EPS\n"
    "        ? vec3(1.0, 0.0, 0.0)\n"
    "        : vec3(0.0, 1.0, 0.0);\n"
    "    u = normalize(cross(tmp, axis));\n"
    "    v = cross(axis, u);\n"
    "}\n"
    "/**\n"
    " * @brief Sample a direction on a hemisphere around the given axis with a cosine-weighted\n"
    "          distribution.\n"
    " * @param axis The normal vector defining the hemisphere.\n"
    " * @param weight The roughness weight for glossy materials (1.0 for diffuse).\n"
    " * @return A sampled direction vector.\n"
    " */\n"
    "vec3 sampleWeightedHemisphere(vec3 axis, float weight) {\n"
    "    vec3 u, v;\n"
    "    buildOrthonormalBasis(axis, u, v);\n"
    "\n"
    "    float w = rand() * weight;\n"
    "    float theta = rand();\n"
    "\n"
    "    vec3 dir =\n"
    "        w * cos(2.0 * PI * theta) * u +\n"
    "        w * sin(2.0 * PI * theta) * v +\n"
    "        sqrt(1.0 - w * w) * axis;\n"
    "\n"
    "    return normalize(dir);\n"
    "}\n"
    "/**\n"
    " * @brief Sample a direction for glass materials based on the incident direction, normal,\n"
    "          and index of refraction.\n"
    " * @param wi The incident direction.\n"
    " * @param n The surface normal at the point of interaction.\n"
    " * @param[inout] inside A flag indicating if the ray is currently inside the material.\n"
    " * @param ior The index of refraction of the material.\n"
    " * @return A sampled direction vector for reflection or refraction.\n"
    " */\n"
    "vec3 sampleGlass(vec3 wi, vec3 n, inout bool inside, float ior) {\n"
    "    float nc = 1.0;\n"
    "    float ng = ior;\n"
    "\n"
    "    float eta = inside ? ng / nc : nc / ng;\n"
    "\n"
    "    float cosi = abs(dot(wi, n));\n"
    "    float r0 = pow((nc - ng) / (nc + ng), 2.0);\n"
    "    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);\n"
    "\n"
    "    vec3 r = reflect(wi, n);\n"
    "\n"
    "    if (k < 0.0)\n"
    "        return r; // Total internal reflection\n"
    "\n"
    "    float re = r0 + (1.0 - r0) * pow(1.0 - cosi, 2.0);\n"
    "\n"
    "    if (rand() < re)\n"
    "        return r;\n"
    "    else {\n"
    "        inside = !inside;\n"
    "        return normalize(\n"
    "            eta * wi - (eta * dot(n, wi) + sqrt(k)) * n\n"
    "        );\n"
    "    }\n"
    "}\n"
    "/**\n"
    " * @brief Sample a point uniformly on a unit disk.\n"
    " * @return A 2D vector representing the sampled point on the disk.\n"
    " */\n"
    "vec2 sampleDisk() {\n"
    "    float r = sqrt(rand());\n"
    "    float theta = 2.0 * PI * rand();\n"
    "    return vec2(cos(theta), sin(theta)) * r;\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Struct representing a ray in 3D space.\n"
    " */\n"
    "struct Ray {\n"
    "    vec3 origin; // Origin of the ray\n"
    "    vec3 direction; // Direction of the ray\n"
    "};\n"
    "\n"
    "/**\n"
    " * @brief Struct representing the result of a ray intersection.\n"
    " */\n"
    "struct HitRecord {\n"
    "    bool hit; // Flag indicating if an intersection occurred\n"
    "    float t; // Distance to intersection\n"
    "    vec3 normal; // Surface normal at intersection\n"
    "    vec3 tangent; // Interpolated tangent at intersection\n"
    "    vec2 texCoord; // Texture coordinates at intersection\n"
    "    uint idxMaterial; // Index of the material at intersection\n"
    "};\n"
    "/**\n"
    " * @brief Function to test ray-triangle intersection.\n"
    " * @param ray The ray to test.\n"
    " * @param tri The triangle to test against.\n"
    " * @return The result of the intersection test.\n"
    " */\n"
    "HitRecord hitTriangle(Ray ray, Triangle tri) {\n"
    "    HitRecord result;\n"
    "    result.t = INFINITY;\n"
    "    result.hit = false;\n"
    "\n"
    "    Vertex v0 = b_vertices.vertices[tri.v0];\n"
    "    Vertex v1 = b_vertices.vertices[tri.v1];\n"
    "    Vertex v2 = b_vertices.vertices[tri.v2];\n"
    "\n"
    "    vec3 p0 = v0.pos.xyz;\n"
    "    vec3 p1 = v1.pos.xyz;\n"
    "    vec3 p2 = v2.pos.xyz;\n"
    "\n"
    "    vec3 e1 = p1 - p0;\n"
    "    vec3 e2 = p2 - p0;\n"
    "\n"
    "    vec3 p = cross(ray.direction, e2);\n"
    "    float det = dot(e1, p);\n"
    "\n"
    "    if (abs(det) < EPS)\n"
    "        return result;\n"
    "\n"
    "    float invDet = 1.0 / det;\n"
    "    vec3 tvec = ray.origin - p0;\n"
    "\n"
    "    float u = dot(tvec, p) * invDet;\n"
    "    if (u < 0.0 || u > 1.0)\n"
    "        return result;\n"
    "\n"
    "    vec3 q = cross(tvec, e1);\n"
    "    float v = dot(ray.direction, q) * invDet;\n"
    "    if (v < 0.0 || (u + v) > 1.0)\n"
    "        return result;\n"
    "\n"
    "    float t = dot(e2, q) * invDet;\n"
    "    if (t < EPS)\n"
    "        return result;\n"
    "\n"
    "    /* ===== Hit confirmed ===== */\n"
    "    result.hit = true;\n"
    "    result.t = t;\n"
    "\n"
    "    float w = 1.0 - u - v;\n"
    "\n"
    "    vec3 n0 = v0.normal.xyz;\n"
    "    vec3 n1 = v1.normal.xyz;\n"
    "    vec3 n2 = v2.normal.xyz;\n"
    "    result.normal = normalize(n0 * w + n1 * u + n2 * v);\n"
    "    if (dot(result.normal, ray.direction) > 0.0f)\n"
    "        result.normal = -result.normal;\n"
    "\n"
    "    vec3 t0v = v0.tangent.xyz;\n"
    "    vec3 t1v = v1.tangent.xyz;\n"
    "    vec3 t2v = v2.tangent.xyz;\n"
    "    vec3 tanInterp = t0v * w + t1v * u + t2v * v;\n"
    "    result.tangent = normalize(tanInterp - result.normal * dot(result.normal, tanInterp));\n"
    "\n"
    "    vec2 uv0 = v0.texCoord;\n"
    "    vec2 uv1 = v1.texCoord;\n"
    "    vec2 uv2 = v2.texCoord;\n"
    "    result.texCoord = uv0 * w + uv1 * u + uv2 * v;\n"
    "\n"
    "    result.idxMaterial = tri.idxMaterial;\n"
    "\n"
    "    return result;\n"
    "}\n"
    "/**\n"
    " * @brief Function to test ray-AABB intersection.\n"
    " * @param ray The ray to test.\n"
    " * @param aabbMin The minimum coordinates of the AABB.\n"
    " * @param aabbMax The maximum coordinates of the AABB.\n"
    " * @return The distance to the intersection or INFINITY if no intersection occurs.\n"
    " */\n"
    "float hitAABB(Ray ray, vec3 aabbMin, vec3 aabbMax) {\n"
    "    vec3 invDir = 1.0 / ray.direction;\n"
    "\n"
    "    vec3 t0 = (aabbMin - ray.origin) * invDir;\n"
    "    vec3 t1 = (aabbMax - ray.origin) * invDir;\n"
    "\n"
    "    vec3 tmin = min(t0, t1);\n"
    "    vec3 tmax = max(t0, t1);\n"
    "\n"
    "    float tNear = max(max(tmin.x, tmin.y), tmin.z);\n"
    "    float tFar  = min(min(tmax.x, tmax.y), tmax.z);\n"
    "\n"
    "    if (tFar < max(tNear, 0.0))\n"
    "        return INFINITY;\n"
    "\n"
    "    return tNear;\n"
    "}\n"
    "/**\n"
    " * @brief Function to traverse the BVH and find the closest intersection.\n"
    " * @param ray The ray to trace.\n"
    " * @return The closest hit record.\n"
    " */\n"
    "HitRecord traverseBVH(Ray ray) {\n"
    "    HitRecord closest;\n"
    "    closest.t = INFINITY;\n"
    "    closest.hit = false;\n"
    "\n"
    "    const int MAX_STACK = 64;\n"
    "    int stack[MAX_STACK];\n"
    "    int stackPtr = 0;\n"
    "\n"
    "    stack[stackPtr++] = 0; // root\n"
    "\n"
    "    while (stackPtr > 0) {\n"
    "        int nodeIdx = stack[--stackPtr];\n"
    "        BvhNode node = b_BVH.bvhNodes[nodeIdx];\n"
    "\n"
    "        float nodeHit = hitAABB(ray, node.aabbMin.xyz, node.aabbMax.xyz);\n"
    "        if (nodeHit == INFINITY || nodeHit > closest.t)\n"
    "            continue;\n"
    "\n"
    "        if (node.leafFlag != 0) {\n"
    "            Triangle tri = b_triangles.triangles[node.idxTriangle];\n"
    "            HitRecord hit = hitTriangle(ray, tri);\n"
    "\n"
    "            if (hit.hit && hit.t < closest.t)\n"
    "                closest = hit;\n"
    "        } else {\n"
    "            int leftChild  = nodeIdx + 1;\n"
    "            int rightChild = int(nodeIdx + node.rChildOffset);\n"
    "\n"
    "            float tLeft = hitAABB(\n"
    "                ray,\n"
    "                b_BVH.bvhNodes[leftChild].aabbMin.xyz,\n"
    "                b_BVH.bvhNodes[leftChild].aabbMax.xyz\n"
    "            );\n"
    "\n"
    "            float tRight = INFINITY;\n"
    "            if (node.rChildOffset != 0) {\n"
    "                tRight = hitAABB(\n"
    "                    ray,\n"
    "                    b_BVH.bvhNodes[rightChild].aabbMin.xyz,\n"
    "                    b_BVH.bvhNodes[rightChild].aabbMax.xyz\n"
    "                );\n"
    "            }\n"
    "\n"
    "            if (tLeft < tRight) {\n"
    "                if (tRight < INFINITY)\n"
    "                    stack[stackPtr++] = rightChild;\n"
    "                if (tLeft < INFINITY)\n"
    "                    stack[stackPtr++] = leftChild;\n"
    "            } else {\n"
    "                if (tLeft < INFINITY)\n"
    "                    stack[stackPtr++] = leftChild;\n"
    "                if (tRight < INFINITY)\n"
    "                    stack[stackPtr++] = rightChild;\n"
    "            }\n"
    "        }\n"
    "    }\n"
    "\n"
    "    return closest;\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Struct to hold polarization information at each interaction.\n"
    " */\n"
    "struct PolarInfo {\n"
    "    vec3 normal; // Interaction normal\n"
    "    vec3 dirOut; // Outgoing direction\n"
    "    vec2 r; // Reflection coefficients (rs, rp)\n"
    "    vec3 s; // Stokes vector\n"
    "};\n"
    "const int MAX_DEPTH = 10; // Maximum trace depth\n"
    "PolarInfo g_polarInfoList[MAX_DEPTH]; // List of polarization info\n"
    "/**\n"
    " * @brief Calculate the Fresnel reflection coefficients for s and p polarizations.\n"
    " * @param n1 Index of refraction of the incident medium.\n"
    " * @param n2 Index of refraction of the transmitted medium.\n"
    " * @param cos_i Cosine of the incident angle.\n"
    " * @return A vec2 containing (rs, rp).\n"
    " */\n"
    "vec2 getRsRp(float n1, float n2, float cos_i) {\n"
    "    cos_i = abs(cos_i);\n"
    "    float cos_t = sqrt(1.0 - (n1 * n1) / (n2 * n2) * (1.0 - cos_i * cos_i));\n"
    "    float rs = (n1 * cos_i - n2 * cos_t) / (n1 * cos_i + n2 * cos_t);\n"
    "    float rp = (n2 * cos_i - n1 * cos_t) / (n1 * cos_t + n2 * cos_i);\n"
    "    return vec2(rs, rp);\n"
    "}\n"
    "/**\n"
    " * @brief Create a rotation matrix for the Stokes vector based on the rotation angle phi.\n"
    " * @param phi The rotation angle in radians.\n"
    " * @return A 3x3 matrix representing the rotation of the Stokes vector.\n"
    " */\n"
    "mat3 stokesRotation(float phi) {\n"
    "    float c = cos(2.0 * phi);\n"
    "    float s = sin(2.0 * phi);\n"
    "    return mat3(\n"
    "        1.0, 0.0, 0.0,\n"
    "        0.0, c,   -s,\n"
    "        0.0, s,   c\n"
    "    );\n"
    "}\n"
    "/**\n"
    " * @brief Calculate the final Stokes vector result based on the ray direction and trace depth.\n"
    " * @param rayDir The direction of the ray.\n"
    " * @param depth The trace depth.\n"
    " * @return The final Stokes vector representing the polarization state.\n"
    " */\n"
    "vec3 calcPolarResult(vec3 rayDir, int depth) {\n"
    "    // Stokes vector: (S0, S1, S2)\n"
    "    vec3 S = vec3(0.0);\n"
    "\n"
    "    if (depth <= 0)\n"
    "        return S;\n"
    "\n"
    "    vec3 s = normalize(vec3(rand() * 2.0 - 1.0, rand() * 2.0 - 1.0, rand() * 2.0 - 1.0));\n"
    "    float phi = 2.0 * PI;\n"
    "\n"
    "    for (int i = depth - 1; i >= 0; --i) {\n"
    "        PolarInfo info = g_polarInfoList[i];\n"
    "\n"
    "        vec3 d = info.dirOut;\n"
    "        vec3 s_old = s;\n"
    "\n"
    "        s = normalize(cross(info.normal, d));\n"
    "        \n"
    "        float cosPhi = clamp(dot(s, s_old), -1.0, 1.0);\n"
    "        phi = acos(cosPhi) * sign(dot(cross(s_old, s), d));\n"
    "\n"
    "        S = stokesRotation(phi) * S;\n"
    "\n"
    "        float rs = info.r.x;\n"
    "        float rp = info.r.y;\n"
    "        float Rs = rs * rs;\n"
    "        float Rp = rp * rp;\n"
    "\n"
    "        mat3 refl = mat3(\n"
    "            vec3((Rs + Rp) / 2.0, (Rs - Rp) / 2.0, 0.0),\n"
    "            vec3((Rs - Rp) / 2.0, (Rs + Rp) / 2.0, 0.0),\n"
    "            vec3(0.0, 0.0, rs * rp)\n"
    "        );\n"
    "\n"
    "        mat3 trans = mat3(\n"
    "            vec3(1.0 - (Rs + Rp) / 2.0, (Rp - Rs) / 2.0, 0.0),\n"
    "            vec3((Rp - Rs) / 2.0, 1.0 - (Rs + Rp) / 2.0, 0.0),\n"
    "            vec3(0.0, 0.0, sqrt((1.0 - Rs) * (1.0 - Rp)))\n"
    "        );\n"
    "\n"
    "        S = refl * S + trans * info.s;\n"
    "    }\n"
    "\n"
    "    vec3 s_cam = normalize(cross(vec3(0.0, 0.0, 1.0), normalize(rayDir)));\n"
    "    float cosPhi = clamp(dot(s_cam, s), -1.0, 1.0);\n"
    "    phi = acos(cosPhi) * sign(dot(cross(s, s_cam), normalize(rayDir)));\n"
    "\n"
    "    return stokesRotation(phi) * S;\n"
    "}\n"
    "\n"
    "/**\n"
    " * @brief Trace a ray through the scene and calculate the resulting color and polarization.\n"
    " * @param ray The ray to trace.\n"
    " * @return A vec4 containing the RGB color and depth (R, G, B, Depth).\n"
    " */\n"
    "vec4 trace(Ray ray) {\n"
    "    Ray newRay = ray;\n"
    "    int bounces = 0;\n"
    "    bool inside = false;\n"
    "    float sceneDepth = 0.0;\n"
    "\n"
    "    while (bounces < u_scene.traceDepth) {\n"
    "        HitRecord hit = traverseBVH(newRay);\n"
    "        if (hit.hit) {\n"
    "            if (bounces == 0)\n"
    "                sceneDepth = hit.t;\n"
    "\n"
    "            vec3 p = newRay.origin + newRay.direction * hit.t;\n"
    "            vec3 n = hit.normal;\n"
    "            Material material = b_materials.materials[hit.idxMaterial];\n"
    "            if ((material.flags & MATERIAL_NORMAL_MAP) != 0) {\n"
    "                vec3 t = hit.tangent;\n"
    "                vec3 b = normalize(cross(n, t));\n"
    "                mat3 TBN = mat3(t, b, n);\n"
    "                vec3 nTex =\n"
    "                    sampleTexture(material.idxNormalTex, hit.texCoord).xyz * 2.0 - 1.0;\n"
    "                n = normalize(TBN * nTex);\n"
    "            }\n"
    "            p += n + EPS;\n"
    "\n"
    "            vec3 wi = newRay.direction;\n"
    "            vec3 wo = reflect(wi, n);\n"
    "\n"
    "            // Material sampling\n"
    "            if (material.type == MATERIAL_TYPE_DIFFUSE)\n"
    "                wo = sampleWeightedHemisphere(n, 1.0);\n"
    "            else if (material.type == MATERIAL_TYPE_GLOSSY) {\n"
    "                float roughness = material.roughness;\n"
    "                if ((material.flags & MATERIAL_ROUGHNESS_MAP) != 0)\n"
    "                    roughness = sampleTexture(material.idxRoughnessTex, hit.texCoord).r;\n"
    "                vec3 r = reflect(wi, n);\n"
    "                wo = sampleWeightedHemisphere(r, roughness);\n"
    "            }\n"
    "            else if (material.type == MATERIAL_TYPE_TRANSLUCENT) {\n"
    "                wo = sampleGlass(wi, n, inside, material.ior);\n"
    "                if (inside)\n"
    "                    p -= n * EPS * 2.0;\n"
    "            }\n"
    "\n"
    "            // Polarization bookkeeping\n"
    "            PolarInfo info;\n"
    "            info.dirOut = wo;\n"
    "            vec3 normal = normalize(wo - wi);\n"
    "            if (abs(1.0 - dot(wo, wi)) < EPS)\n"
    "                normal = n;\n"
    "            info.normal = normal;\n"
    "            info.r = getRsRp(1.0, material.ior, dot(info.normal, wi));\n"
    "            float theta = 2.0 * PI * rand();\n"
    "            float intensity = material.intensity;\n"
    "            info.s = vec3(1.0, cos(theta), sin(theta)) * intensity;\n"
    "            g_polarInfoList[bounces] = info;\n"
    "\n"
    "            // Next ray\n"
    "            newRay.origin = p;\n"
    "            newRay.direction = wo;\n"
    "            bounces++;\n"
    "        } else\n"
    "            break;\n"
    "    }\n"
    "\n"
    "    return vec4(calcPolarResult(ray.direction, bounces), sceneDepth);\n"
    "}\n"
    "\n"
    "void main() {\n"
    "    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);\n"
    "\n"
    "    if (pixel.x >= u_scene.resX || pixel.y >= u_scene.resY)\n"
    "        return;\n"
    "\n"
    "    initRngState(pixel, u_scene.currentSample);\n"
    "\n"
    "    vec2 uv = (vec2(pixel) + 0.5) / vec2(u_scene.resX, u_scene.resY);\n"
    "    vec2 ndc = uv * 2.0 - 1.0;\n"
    "\n"
    "    vec3 forward = normalize(u_camera.dir.xyz);\n"
    "    vec3 right = normalize(cross(forward, u_camera.up.xyz));\n"
    "    vec3 up = cross(right, forward);\n"
    "\n"
    "    float halfHeight = tan(radians(u_camera.fov * 0.5)) * u_camera.focal;\n"
    "    float halfWidth  = halfHeight * float(u_scene.resX) / float(u_scene.resY);\n"
    "\n"
    "    vec3 imageCenter = u_camera.pos.xyz + forward * u_camera.focal;\n"
    "    vec3 imagePoint = imageCenter + ndc.x * halfWidth * right + ndc.y * halfHeight * up;\n"
    "\n"
    "    vec3 pinholeDir = normalize(imagePoint - u_camera.pos.xyz);\n"
    "    // Focus plane intersection\n"
    "    float tFocus = u_camera.focusDist / dot(pinholeDir, forward);\n"
    "    vec3 focusPoint = u_camera.pos.xyz + pinholeDir * tFocus;\n"
    "    // Aperture\n"
    "    float apertureRadius = 0.5 * (u_camera.focal / u_camera.fStop);\n"
    "    // Lens sampling\n"
    "    vec2 lensSample = sampleDisk() * apertureRadius;\n"
    "    vec3 lensOffset = right * lensSample.x + up * lensSample.y;\n"
    "\n"
    "    Ray ray;\n"
    "    ray.origin = u_camera.pos.xyz + lensOffset;\n"
    "    ray.direction = normalize(focusPoint - ray.origin);\n"
    "    vec4 color = trace(ray);\n"
    "\n"
    "    if (u_scene.currentSample > 1)\n"
    "        color += imageLoad(u_outImg, pixel) * (u_scene.currentSample - 1);\n"
    "    imageStore(u_outImg, pixel, vec4(color / float(u_scene.currentSample)));\n"
    "}\n"
    "";

// Source: preview.frag
inline constexpr const char* PREVIEW_FRAG =
    "/**\n"
    " * @file preview.frag\n"
    " * @brief Fragment shader for the previewer.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "layout(location = 0) in vec3 v_posW; // World space position\n"
    "layout(location = 1) in vec3 v_normalW; // World space normal\n"
    "layout(location = 2) in vec3 v_tangentW; // World space tangent\n"
    "layout(location = 3) in vec2 v_texCoord; // Texture coordinate\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct for camera position.\n"
    " */\n"
    "#ifdef VULKAN\n"
    "layout(set = 2, binding = 1)\n"
    "#else\n"
    "layout(binding = 1)\n"
    "#endif\n"
    "uniform Camera {\n"
    "    vec3 posW; // Camera world position\n"
    "} u_camera; // Camera data\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct for material properties.\n"
    " */\n"
    "layout(binding = 2) uniform Material {\n"
    "    vec4 diffuse; // Diffuse color (or highlight color)\n"
    "    float roughness; // Roughness\n"
    "    uint flags; // Material flags\n"
    "} u_material; // Material data\n"
    "const uint MATERIAL_NORMAL_MAP = 1 << 0; // Has normal texture\n"
    "const uint MATERIAL_ROUGHNESS_MAP = 1 << 1; // Has roughness texture\n"
    "const uint MATERIAL_INTENSITY_MAP = 1 << 2; // Has intensity texture (not used)\n"
    "const uint MATERIAL_HIGHLIGHT = 1 << 3; // Highlighted material\n"
    "\n"
    "layout(binding = 3) uniform sampler2D u_normalTex; // Normal texture\n"
    "layout(binding = 4) uniform sampler2D u_roughnessTex; // Roughness texture\n"
    "layout(binding = 5) uniform sampler2D u_intensityTex; // Intensity texture\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct for object picking information.\n"
    " */\n"
    "layout(binding = 6) uniform PickInfo {\n"
    "    uint modelID; // Model ID\n"
    "    uint meshID; // Mesh ID\n"
    "} u_pickInfo; // Picking information\n"
    "\n"
    "layout(location = 0) out vec4 o_fragColor; // Final fragment color\n"
    "layout(location = 1) out vec4 o_pickColor; // Picking color for color pick buffer\n"
    "\n"
    "void main() {\n"
    "    // Light direction in world space (camera as light source)\n"
    "    vec3 l = normalize(u_camera.posW - v_posW);\n"
    "    // Normal in world space\n"
    "    vec3 n = normalize(v_normalW);\n"
    "    if (dot(n, l) < 0.0)\n"
    "        n = -n;\n"
    "    if ((u_material.flags & MATERIAL_NORMAL_MAP) != 0) {\n"
    "        vec3 bitangentW = normalize(cross(v_normalW, v_tangentW));\n"
    "        mat3 tbn = mat3(v_tangentW, bitangentW, v_normalW);\n"
    "        vec3 nt = normalize(texture(u_normalTex, v_texCoord).xyz * 2.0 - 1.0);\n"
    "        n = tbn * nt;\n"
    "    }\n"
    "\n"
    "    float roughness = u_material.roughness;\n"
    "    if ((u_material.flags & MATERIAL_ROUGHNESS_MAP) != 0)\n"
    "        roughness = texture(u_roughnessTex, v_texCoord).r;\n"
    "\n"
    "    vec3 diffuse = u_material.diffuse.rgb;\n"
    "    if ((u_material.flags & MATERIAL_INTENSITY_MAP) != 0)\n"
    "        diffuse = texture(u_intensityTex, v_texCoord).rgb;\n"
    "    diffuse *= max(dot(n, l), 0.0);\n"
    "\n"
    "    vec3 specular = vec3(1.0);\n"
    "    float specularFact = pow(max(dot(n, l), 0.0), 128.0 * (1.0 - roughness));\n"
    "    specularFact *= max(dot(n, l), 0.0);\n"
    "    specular *= specularFact;\n"
    "\n"
    "    vec3 shade = (diffuse + specular) * 0.5;\n"
    "    if ((u_material.flags & MATERIAL_HIGHLIGHT) != 0)\n"
    "        shade = diffuse;\n"
    "\n"
    "    o_fragColor = vec4(shade, 1.0);\n"
    "\n"
    "    o_pickColor = vec4(u_pickInfo.modelID, u_pickInfo.meshID, 1.0, 1.0);\n"
    "}\n"
    "";

// Source: preview.vert
inline constexpr const char* PREVIEW_VERT =
    "/**\n"
    " * @file preview.vert\n"
    " * @brief Vertex shader for the previewer.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "layout(location = 0) in vec3 i_pos; // Vertex position\n"
    "layout(location = 1) in vec3 i_normal; // Vertex normal\n"
    "layout(location = 2) in vec3 i_tangent; // Vertex tangent\n"
    "layout(location = 3) in vec2 i_texCoord; // Vertex texture coordinate\n"
    "\n"
    "/**\n"
    " * @brief Uniform struct for model, view, and projection matrices.\n"
    " */\n"
    " #ifdef VULKAN\n"
    "layout(set = 1, binding = 0)\n"
    "#else\n"
    "layout(binding = 0)\n"
    "#endif\n"
    "uniform Xform {\n"
    "    mat4 proj; // Projection matrix\n"
    "    mat4 view; // View matrix\n"
    "    mat4 model; // Model matrix\n"
    "} u_xform; // Transformation matrices\n"
    "\n"
    "layout(location = 0) out vec3 v_posW; // World space position\n"
    "layout(location = 1) out vec3 v_normalW; // World space normal\n"
    "layout(location = 2) out vec3 v_tangentW; // World space tangent\n"
    "layout(location = 3) out vec2 v_texCoord; // Texture coordinate\n"
    "\n"
    "void main() {\n"
    "    v_posW = vec3(u_xform.model * vec4(i_pos, 1.0));\n"
    "    v_normalW = normalize(mat3(u_xform.model) * i_normal);\n"
    "    v_tangentW = normalize(mat3(u_xform.model) * i_tangent);\n"
    "    v_texCoord = i_texCoord;\n"
    "\n"
    "    gl_Position = u_xform.proj * u_xform.view * vec4(v_posW, 1.0);\n"
    "}\n"
    "";

// Source: quad.frag
inline constexpr const char* QUAD_FRAG =
    "/**\n"
    " * @file quad.frag\n"
    " * @brief Fragment shader for rendering a textured quad.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "layout(location = 0) in vec2 v_texCoord; // Texture coordinate\n"
    "\n"
    "layout(binding = 0) uniform sampler2D u_texture; // Texture sampler\n"
    "\n"
    "/**\n"
    " * @brief Uniform buffer for shader parameters.\n"
    " */\n"
    "layout(binding = 1) uniform Params {\n"
    "    int channel; // Channel selection (0 for red, 1 for green, 2 for blue)\n"
    "} u_params; // Shader parameters\n"
    "\n"
    "layout(location = 0) out vec4 o_fragColor; // Final fragment color\n"
    "\n"
    "void main() {\n"
    "    vec3 color = texture(u_texture, v_texCoord).rgb;\n"
    "    o_fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
    "    if (u_params.channel == 0) {\n"
    "        color *= 5.0;\n"
    "        o_fragColor = vec4(color.rrr, 1.0);\n"
    "    } else {\n"
    "        color = 1.0 - (color + 0.025) * 20.0;\n"
    "        if (u_params.channel == 1)\n"
    "            o_fragColor = vec4(color.ggg, 1.0);\n"
    "        else if (u_params.channel == 2)\n"
    "            o_fragColor = vec4(color.bbb, 1.0);\n"
    "    }\n"
    "}\n"
    "";

// Source: quad.vert
inline constexpr const char* QUAD_VERT =
    "/**\n"
    " * @file quad.vert\n"
    " * @brief Vertex shader for rendering a textured quad.\n"
    " */\n"
    "\n"
    "#version 450\n"
    "\n"
    "#ifdef VULKAN\n"
    "#define gl_VertexID gl_VertexIndex\n"
    "#endif\n"
    "\n"
    "layout(location = 0) out vec2 v_texCoord; // Output texture coordinates\n"
    "\n"
    "// Predefined vertex positions for a full-screen quad\n"
    "const vec4 g_vertices[4] = vec4[](\n"
    "    vec4(-1.0, -1.0, 0.0, 1.0),\n"
    "    vec4( 1.0, -1.0, 0.0, 1.0),\n"
    "    vec4(-1.0,  1.0, 0.0, 1.0),\n"
    "    vec4( 1.0,  1.0, 0.0, 1.0)\n"
    ");\n"
    "\n"
    "void main() {\n"
    "    gl_Position = g_vertices[gl_VertexID];\n"
    "    v_texCoord = (gl_Position.xy + vec2(1.0)) * 0.5;\n"
    "}\n"
    "";

/**
 * @brief Retrieve the shader string by name.
 * @param name The name of the shader file.
 * @return The shader source code as a string, or an empty string if not found.
 */
inline std::string get(const std::string& name) {
    static const auto map = std::unordered_map<std::string, std::string> {
        { "pathTracer.comp", PATHTRACER_COMP },
        { "preview.frag", PREVIEW_FRAG },
        { "preview.vert", PREVIEW_VERT },
        { "quad.frag", QUAD_FRAG },
        { "quad.vert", QUAD_VERT },
    };
    if (auto it = map.find(name); it != map.end())
        return it->second;
    return {};
}

} // namespace ShaderStrings
