/**
 * @file pathTracer.comp
 * @brief Compute shader for path tracing rendering.
 */

#version 450

#ifndef VULKAN
#extension GL_ARB_bindless_texture : require
#else
#extension GL_EXT_nonuniform_qualifier : require
#endif

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba32f) uniform image2D u_outImg; // Output image

/**
 * @brief Uniform struct representing the scene parameters.
 */
layout(binding = 1) uniform Scene {
    int resX; // Resolution in X
    int resY; // Resolution in Y
    int traceDepth; // Trace depth
    int currentSample; // Current sample count
} u_scene; // Scene parameters

/**
 * @brief Uniform struct representing the camera parameters.
 */
layout(binding = 2) uniform Camera {
    vec4 pos; // Camera position
    vec4 dir; // Camera direction
    vec4 up; // Camera up vector

    float focal; // Focal length
    float fov; // Field of view
    float focusDist; // Focus distance
    float fStop; // F-stop value
} u_camera; // Camera parameters

#ifdef VULKAN
layout(binding = 3) uniform sampler2D u_textures[]; // Array of textures
#else
layout(binding = 3) buffer Textures {
    sampler2D u_textures[]; // Array of textures
};
#endif

/**
 * @brief Sample a texture at given UV coordinates.
 * @param index The index of the texture.
 * @param uv The UV coordinates.
 * @return The sampled color.
 */
vec4 sampleTexture(uint index, vec2 uv) {
#ifdef VULKAN
    return texture(u_textures[nonuniformEXT(index)], uv);
#else
    return texture(sampler2D(u_textures[index]), uv);
#endif
}

/**
 * @brief Struct representing a vertex in the mesh.
 */
struct Vertex {
    vec4 pos; // Position
    vec4 normal; // Normal
    vec4 tangent; // Tangent
    vec2 texCoord; // Texture Coordinate
    vec2 padding; // Padding for alignment
};
/**
 * @brief Storage buffer containing the vertices of the mesh.
 */
layout(binding = 4) readonly buffer Vertices {
    Vertex vertices[]; // Array of vertices
} b_vertices; // Vertex buffer

/**
 * @brief Struct representing a triangle in the mesh.
 */
struct Triangle {
    uint v0; // Index of vertex 0
    uint v1; // Index of vertex 1
    uint v2; // Index of vertex 2
    uint idxMaterial; // Index of the material
};
/**
 * @brief Storage buffer containing the triangles of the mesh.
 */
layout(binding = 5) readonly buffer Triangles {
    Triangle triangles[]; // Array of triangles
} b_triangles; // Triangle buffer

/**
 * @brief Struct representing a material for a mesh.
 */
struct Material {
    int type; // Material type
    float roughness; // Roughness
    float intensity; // Intensity
    float ior; // Index of Refraction

    uint flags; // Material flags
    uint idxNormalTex; // Index of normal texture
    uint idxRoughnessTex; // Index of roughness texture
    uint idxIntensityTex; // Index of intensity texture
};

const int MATERIAL_TYPE_DIFFUSE = 0; // Diffuse material
const int MATERIAL_TYPE_SPECULAR = 1; // Specular material
const int MATERIAL_TYPE_GLOSSY = 2; // Glossy material
const int MATERIAL_TYPE_TRANSLUCENT = 3; // Translucent material

const uint MATERIAL_NORMAL_MAP = 1 << 0; // Has normal texture
const uint MATERIAL_ROUGHNESS_MAP = 1 << 1; // Has roughness texture
const uint MATERIAL_INTENSITY_MAP = 1 << 2; // Has intensity texture

/**
 * @brief Storage buffer containing the materials of the mesh.
 */
layout(binding = 6) readonly buffer Materials {
    Material materials[]; // Array of materials
} b_materials; // Material buffer

/**
 * @brief Struct representing a BVH node.
 */
struct BvhNode {
    uint idx; // Index of this node
    uint rChildOffset; // Offset to the right child node
    uint idxTriangle; // Index of the triangle (if leaf node)
    uint leafFlag; // Flag indicating if this is a leaf node

    vec4 aabbMin; // Minimum AABB coordinates
    vec4 aabbMax; // Maximum AABB coordinates
};
/**
 * @brief Storage buffer containing the BVH nodes.
 */
layout(binding = 7) readonly buffer BVH {
    BvhNode bvhNodes[]; // Array of BVH nodes
} b_BVH; // BVH buffer

const float EPS = 0.00001; // Small epsilon value
const float INFINITY = 1e20; // Large value representing infinity
const float PI = 3.14159265359; // Value of pi

uint g_rngState = 0; // Global RNG state
/**
 * @brief Initialize the RNG state based on pixel coordinates and current sample.
 * @param pixel The pixel coordinates.
 * @param currentSample The current sample index.
 */
void initRngState(ivec2 pixel, int currentSample) {
    g_rngState = uint(pixel.x * 1973u + pixel.y * 9277u + currentSample * 26699u) | 1u;
}
/**
 * @brief Generate a random float in the range [0, 1).
 * @return A random float.
 */
float rand() {
    g_rngState ^= g_rngState << 13;
    g_rngState ^= g_rngState >> 17;
    g_rngState ^= g_rngState << 5;
    return float(g_rngState) * (1.0 / 4294967296.0);
}

/**
 * @brief Build an orthonormal basis (u, v) given a normal vector (axis).
 * @param axis The normal vector.
 * @param[out] u Output vector for the first tangent.
 * @param[out] v Output vector for the second tangent.
 */
void buildOrthonormalBasis(vec3 axis, out vec3 u, out vec3 v) {
    vec3 tmp = abs(axis.x) < 1.0 - EPS
        ? vec3(1.0, 0.0, 0.0)
        : vec3(0.0, 1.0, 0.0);
    u = normalize(cross(tmp, axis));
    v = cross(axis, u);
}
/**
 * @brief Sample a direction on a hemisphere around the given axis with a cosine-weighted
          distribution.
 * @param axis The normal vector defining the hemisphere.
 * @param weight The roughness weight for glossy materials (1.0 for diffuse).
 * @return A sampled direction vector.
 */
vec3 sampleWeightedHemisphere(vec3 axis, float weight) {
    vec3 u, v;
    buildOrthonormalBasis(axis, u, v);

    float w = rand() * weight;
    float theta = rand();

    vec3 dir =
        w * cos(2.0 * PI * theta) * u +
        w * sin(2.0 * PI * theta) * v +
        sqrt(1.0 - w * w) * axis;

    return normalize(dir);
}
/**
 * @brief Sample a direction for glass materials based on the incident direction, normal,
          and index of refraction.
 * @param wi The incident direction.
 * @param n The surface normal at the point of interaction.
 * @param[inout] inside A flag indicating if the ray is currently inside the material.
 * @param ior The index of refraction of the material.
 * @return A sampled direction vector for reflection or refraction.
 */
vec3 sampleGlass(vec3 wi, vec3 n, inout bool inside, float ior) {
    float nc = 1.0;
    float ng = ior;

    float eta = inside ? ng / nc : nc / ng;

    float cosi = abs(dot(wi, n));
    float r0 = pow((nc - ng) / (nc + ng), 2.0);
    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);

    vec3 r = reflect(wi, n);

    if (k < 0.0)
        return r; // Total internal reflection

    float re = r0 + (1.0 - r0) * pow(1.0 - cosi, 2.0);

    if (rand() < re)
        return r;
    else {
        inside = !inside;
        return normalize(
            eta * wi - (eta * dot(n, wi) + sqrt(k)) * n
        );
    }
}
/**
 * @brief Sample a point uniformly on a unit disk.
 * @return A 2D vector representing the sampled point on the disk.
 */
vec2 sampleDisk() {
    float r = sqrt(rand());
    float theta = 2.0 * PI * rand();
    return vec2(cos(theta), sin(theta)) * r;
}

/**
 * @brief Struct representing a ray in 3D space.
 */
struct Ray {
    vec3 origin; // Origin of the ray
    vec3 direction; // Direction of the ray
};

/**
 * @brief Struct representing the result of a ray intersection.
 */
struct HitRecord {
    bool hit; // Flag indicating if an intersection occurred
    float t; // Distance to intersection
    vec3 normal; // Surface normal at intersection
    vec3 tangent; // Interpolated tangent at intersection
    vec2 texCoord; // Texture coordinates at intersection
    uint idxMaterial; // Index of the material at intersection
};
/**
 * @brief Function to test ray-triangle intersection.
 * @param ray The ray to test.
 * @param tri The triangle to test against.
 * @return The result of the intersection test.
 */
HitRecord hitTriangle(Ray ray, Triangle tri) {
    HitRecord result;
    result.t = INFINITY;
    result.hit = false;

    Vertex v0 = b_vertices.vertices[tri.v0];
    Vertex v1 = b_vertices.vertices[tri.v1];
    Vertex v2 = b_vertices.vertices[tri.v2];

    vec3 p0 = v0.pos.xyz;
    vec3 p1 = v1.pos.xyz;
    vec3 p2 = v2.pos.xyz;

    vec3 e1 = p1 - p0;
    vec3 e2 = p2 - p0;

    vec3 p = cross(ray.direction, e2);
    float det = dot(e1, p);

    if (abs(det) < EPS)
        return result;

    float invDet = 1.0 / det;
    vec3 tvec = ray.origin - p0;

    float u = dot(tvec, p) * invDet;
    if (u < 0.0 || u > 1.0)
        return result;

    vec3 q = cross(tvec, e1);
    float v = dot(ray.direction, q) * invDet;
    if (v < 0.0 || (u + v) > 1.0)
        return result;

    float t = dot(e2, q) * invDet;
    if (t < EPS)
        return result;

    /* ===== Hit confirmed ===== */
    result.hit = true;
    result.t = t;

    float w = 1.0 - u - v;

    vec3 n0 = v0.normal.xyz;
    vec3 n1 = v1.normal.xyz;
    vec3 n2 = v2.normal.xyz;
    result.normal = normalize(n0 * w + n1 * u + n2 * v);
    if (dot(result.normal, ray.direction) > 0.0f)
        result.normal = -result.normal;

    vec3 t0v = v0.tangent.xyz;
    vec3 t1v = v1.tangent.xyz;
    vec3 t2v = v2.tangent.xyz;
    vec3 tanInterp = t0v * w + t1v * u + t2v * v;
    result.tangent = normalize(tanInterp - result.normal * dot(result.normal, tanInterp));

    vec2 uv0 = v0.texCoord;
    vec2 uv1 = v1.texCoord;
    vec2 uv2 = v2.texCoord;
    result.texCoord = uv0 * w + uv1 * u + uv2 * v;

    result.idxMaterial = tri.idxMaterial;

    return result;
}
/**
 * @brief Function to test ray-AABB intersection.
 * @param ray The ray to test.
 * @param aabbMin The minimum coordinates of the AABB.
 * @param aabbMax The maximum coordinates of the AABB.
 * @return The distance to the intersection or INFINITY if no intersection occurs.
 */
float hitAABB(Ray ray, vec3 aabbMin, vec3 aabbMax) {
    vec3 invDir = 1.0 / ray.direction;

    vec3 t0 = (aabbMin - ray.origin) * invDir;
    vec3 t1 = (aabbMax - ray.origin) * invDir;

    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);

    float tNear = max(max(tmin.x, tmin.y), tmin.z);
    float tFar  = min(min(tmax.x, tmax.y), tmax.z);

    if (tFar < max(tNear, 0.0))
        return INFINITY;

    return tNear;
}
/**
 * @brief Function to traverse the BVH and find the closest intersection.
 * @param ray The ray to trace.
 * @return The closest hit record.
 */
HitRecord traverseBVH(Ray ray) {
    HitRecord closest;
    closest.t = INFINITY;
    closest.hit = false;

    const int MAX_STACK = 64;
    int stack[MAX_STACK];
    int stackPtr = 0;

    stack[stackPtr++] = 0; // root

    while (stackPtr > 0) {
        int nodeIdx = stack[--stackPtr];
        BvhNode node = b_BVH.bvhNodes[nodeIdx];

        float nodeHit = hitAABB(ray, node.aabbMin.xyz, node.aabbMax.xyz);
        if (nodeHit == INFINITY || nodeHit > closest.t)
            continue;

        if (node.leafFlag != 0) {
            Triangle tri = b_triangles.triangles[node.idxTriangle];
            HitRecord hit = hitTriangle(ray, tri);

            if (hit.hit && hit.t < closest.t)
                closest = hit;
        } else {
            int leftChild  = nodeIdx + 1;
            int rightChild = int(nodeIdx + node.rChildOffset);

            float tLeft = hitAABB(
                ray,
                b_BVH.bvhNodes[leftChild].aabbMin.xyz,
                b_BVH.bvhNodes[leftChild].aabbMax.xyz
            );

            float tRight = INFINITY;
            if (node.rChildOffset != 0) {
                tRight = hitAABB(
                    ray,
                    b_BVH.bvhNodes[rightChild].aabbMin.xyz,
                    b_BVH.bvhNodes[rightChild].aabbMax.xyz
                );
            }

            if (tLeft < tRight) {
                if (tRight < INFINITY)
                    stack[stackPtr++] = rightChild;
                if (tLeft < INFINITY)
                    stack[stackPtr++] = leftChild;
            } else {
                if (tLeft < INFINITY)
                    stack[stackPtr++] = leftChild;
                if (tRight < INFINITY)
                    stack[stackPtr++] = rightChild;
            }
        }
    }

    return closest;
}

/**
 * @brief Struct to hold polarization information at each interaction.
 */
struct PolarInfo {
    vec3 normal; // Interaction normal
    vec3 dirOut; // Outgoing direction
    vec2 r; // Reflection coefficients (rs, rp)
    vec3 s; // Stokes vector
};
const int MAX_DEPTH = 10; // Maximum trace depth
PolarInfo g_polarInfoList[MAX_DEPTH]; // List of polarization info
/**
 * @brief Calculate the Fresnel reflection coefficients for s and p polarizations.
 * @param n1 Index of refraction of the incident medium.
 * @param n2 Index of refraction of the transmitted medium.
 * @param cos_i Cosine of the incident angle.
 * @return A vec2 containing (rs, rp).
 */
vec2 getRsRp(float n1, float n2, float cos_i) {
    cos_i = abs(cos_i);
    float cos_t = sqrt(1.0 - (n1 * n1) / (n2 * n2) * (1.0 - cos_i * cos_i));
    float rs = (n1 * cos_i - n2 * cos_t) / (n1 * cos_i + n2 * cos_t);
    float rp = (n2 * cos_i - n1 * cos_t) / (n1 * cos_t + n2 * cos_i);
    return vec2(rs, rp);
}
/**
 * @brief Create a rotation matrix for the Stokes vector based on the rotation angle phi.
 * @param phi The rotation angle in radians.
 * @return A 3x3 matrix representing the rotation of the Stokes vector.
 */
mat3 stokesRotation(float phi) {
    float c = cos(2.0 * phi);
    float s = sin(2.0 * phi);
    return mat3(
        1.0, 0.0, 0.0,
        0.0, c,   -s,
        0.0, s,   c
    );
}
/**
 * @brief Calculate the final Stokes vector result based on the ray direction and trace depth.
 * @param rayDir The direction of the ray.
 * @param depth The trace depth.
 * @return The final Stokes vector representing the polarization state.
 */
vec3 calcPolarResult(vec3 rayDir, int depth) {
    // Stokes vector: (S0, S1, S2)
    vec3 S = vec3(0.0);

    if (depth <= 0)
        return S;

    vec3 s = normalize(vec3(rand() * 2.0 - 1.0, rand() * 2.0 - 1.0, rand() * 2.0 - 1.0));
    float phi = 2.0 * PI;

    for (int i = depth - 1; i >= 0; --i) {
        PolarInfo info = g_polarInfoList[i];

        vec3 d = info.dirOut;
        vec3 s_old = s;

        s = normalize(cross(info.normal, d));
        
        float cosPhi = clamp(dot(s, s_old), -1.0, 1.0);
        phi = acos(cosPhi) * sign(dot(cross(s_old, s), d));

        S = stokesRotation(phi) * S;

        float rs = info.r.x;
        float rp = info.r.y;
        float Rs = rs * rs;
        float Rp = rp * rp;

        mat3 refl = mat3(
            vec3((Rs + Rp) / 2.0, (Rs - Rp) / 2.0, 0.0),
            vec3((Rs - Rp) / 2.0, (Rs + Rp) / 2.0, 0.0),
            vec3(0.0, 0.0, rs * rp)
        );

        mat3 trans = mat3(
            vec3(1.0 - (Rs + Rp) / 2.0, (Rp - Rs) / 2.0, 0.0),
            vec3((Rp - Rs) / 2.0, 1.0 - (Rs + Rp) / 2.0, 0.0),
            vec3(0.0, 0.0, sqrt((1.0 - Rs) * (1.0 - Rp)))
        );

        S = refl * S + trans * info.s;
    }

    vec3 s_cam = normalize(cross(vec3(0.0, 0.0, 1.0), normalize(rayDir)));
    float cosPhi = clamp(dot(s_cam, s), -1.0, 1.0);
    phi = acos(cosPhi) * sign(dot(cross(s, s_cam), normalize(rayDir)));

    return stokesRotation(phi) * S;
}

/**
 * @brief Trace a ray through the scene and calculate the resulting color and polarization.
 * @param ray The ray to trace.
 * @return A vec4 containing the RGB color and depth (R, G, B, Depth).
 */
vec4 trace(Ray ray) {
    Ray newRay = ray;
    int bounces = 0;
    bool inside = false;
    float sceneDepth = 0.0;

    while (bounces < u_scene.traceDepth) {
        HitRecord hit = traverseBVH(newRay);
        if (hit.hit) {
            if (bounces == 0)
                sceneDepth = hit.t;

            vec3 p = newRay.origin + newRay.direction * hit.t;
            vec3 n = hit.normal;
            Material material = b_materials.materials[hit.idxMaterial];
            if ((material.flags & MATERIAL_NORMAL_MAP) != 0) {
                vec3 t = hit.tangent;
                vec3 b = normalize(cross(n, t));
                mat3 TBN = mat3(t, b, n);
                vec3 nTex =
                    sampleTexture(material.idxNormalTex, hit.texCoord).xyz * 2.0 - 1.0;
                n = normalize(TBN * nTex);
            }
            p += n + EPS;

            vec3 wi = newRay.direction;
            vec3 wo = reflect(wi, n);

            // Material sampling
            if (material.type == MATERIAL_TYPE_DIFFUSE)
                wo = sampleWeightedHemisphere(n, 1.0);
            else if (material.type == MATERIAL_TYPE_GLOSSY) {
                float roughness = material.roughness;
                if ((material.flags & MATERIAL_ROUGHNESS_MAP) != 0)
                    roughness = sampleTexture(material.idxRoughnessTex, hit.texCoord).r;
                vec3 r = reflect(wi, n);
                wo = sampleWeightedHemisphere(r, roughness);
            }
            else if (material.type == MATERIAL_TYPE_TRANSLUCENT) {
                wo = sampleGlass(wi, n, inside, material.ior);
                if (inside)
                    p -= n * EPS * 2.0;
            }

            // Polarization bookkeeping
            PolarInfo info;
            info.dirOut = wo;
            vec3 normal = normalize(wo - wi);
            if (abs(1.0 - dot(wo, wi)) < EPS)
                normal = n;
            info.normal = normal;
            info.r = getRsRp(1.0, material.ior, dot(info.normal, wi));
            float theta = 2.0 * PI * rand();
            float intensity = material.intensity;
            info.s = vec3(1.0, cos(theta), sin(theta)) * intensity;
            g_polarInfoList[bounces] = info;

            // Next ray
            newRay.origin = p;
            newRay.direction = wo;
            bounces++;
        } else
            break;
    }

    return vec4(calcPolarResult(ray.direction, bounces), sceneDepth);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    if (pixel.x >= u_scene.resX || pixel.y >= u_scene.resY)
        return;

    initRngState(pixel, u_scene.currentSample);

    vec2 uv = (vec2(pixel) + 0.5) / vec2(u_scene.resX, u_scene.resY);
    vec2 ndc = uv * 2.0 - 1.0;

    vec3 forward = normalize(u_camera.dir.xyz);
    vec3 right = normalize(cross(forward, u_camera.up.xyz));
    vec3 up = cross(right, forward);

    float halfHeight = tan(radians(u_camera.fov * 0.5)) * u_camera.focal;
    float halfWidth  = halfHeight * float(u_scene.resX) / float(u_scene.resY);

    vec3 imageCenter = u_camera.pos.xyz + forward * u_camera.focal;
    vec3 imagePoint = imageCenter + ndc.x * halfWidth * right + ndc.y * halfHeight * up;

    vec3 pinholeDir = normalize(imagePoint - u_camera.pos.xyz);
    // Focus plane intersection
    float tFocus = u_camera.focusDist / dot(pinholeDir, forward);
    vec3 focusPoint = u_camera.pos.xyz + pinholeDir * tFocus;
    // Aperture
    float apertureRadius = 0.5 * (u_camera.focal / u_camera.fStop);
    // Lens sampling
    vec2 lensSample = sampleDisk() * apertureRadius;
    vec3 lensOffset = right * lensSample.x + up * lensSample.y;

    Ray ray;
    ray.origin = u_camera.pos.xyz + lensOffset;
    ray.direction = normalize(focusPoint - ray.origin);
    vec4 color = trace(ray);

    if (u_scene.currentSample > 1)
        color += imageLoad(u_outImg, pixel) * (u_scene.currentSample - 1);
    imageStore(u_outImg, pixel, vec4(color / float(u_scene.currentSample)));
}
